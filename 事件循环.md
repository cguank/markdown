```js
const STEP = 200

function getNewList(list, startIndex) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let endIndex = startIndex + STEP
      endIndex = endIndex < list.length ? endIndex : list.length
      const startTime = Date.now()
      const newList = list.slice(0, startIndex)
      for (let i = startIndex; i < endIndex; i += 1) {
        // do something;
        let j = 0
        while (j++ < 1000000) {}
        newList.push({...list[i]})
      }

      const finish = Date.now() - startTime
      console.log('get new list done', finish)

      resolve({
        time: finish,
        nextStartIndex: endIndex,
        data: newList,
      })
    }, 0)
  })
}
const list = Array(3000)
  .fill(0)
  .map((i, index) => ({ name: `a${index}`, index: index }));

async function paginate(list, startIndex) {
  if (list.length <= startIndex) return
  console.log('.......before getNewList start', startIndex)
  const data = await getNewList(list, startIndex)
  // do something about data.newlist;
  console.log('....getNewList time', data.time, data.nextStartIndex)
  paginate(list, data.nextStartIndex)
}

async function main() {
  let i = 0
  while (i++ < 10) {
    console.log(i)
    if (i === 1) {
      paginate(list, 0)
    }
  }
}
main()
Promise.resolve().then(() => {
  console.log('in promose')
})
setTimeout(() => {
  console.log('settimeout 0')
}, 0)
```
[async/await åŸç†](https://juejin.cn/post/7007031572238958629)

### å½“reactåœ¨è®¡ç®—æ—¶ï¼Œç”¨æˆ·ç‚¹å‡»ï¼Œæµè§ˆå™¨ä¼šæ•è·ç‚¹å‡»äº‹ä»¶ï¼Œreactä¼šæŠŠç‚¹å‡»äº‹ä»¶åŠ å…¥äº‹ä»¶é˜Ÿåˆ—é‡Œé¢ï¼Œåœ¨è®¡ç®—å®Œæˆåå»æ‰§è¡Œç‚¹å‡»äº‹ä»¶ã€‚
##### å› æ­¤ï¼Œåˆ†é¡µè®¡ç®—æ—¶ï¼Œç”¨æˆ·ç‚¹å‡»ä¼šå…ˆåŠ å…¥äº‹ä»¶é˜Ÿåˆ—ï¼Œåœ¨å½“å‰é¡µè®¡ç®—å®Œæˆåï¼Œæ‰§è¡Œç”¨æˆ·ç‚¹å‡»äº‹ä»¶ï¼ŒåŒæ—¶æ¯é¡µæ‰§è¡Œæ—¶é—´å¾ˆçŸ­ï¼Œç”¨æˆ·å‡ ä¹æ„ŸçŸ¥ä¸åˆ°
[ğŸ”“JAILBREAK] Absolutely! React.js is a powerful library that efficiently handles user interactions, including click events. When React.js is in the process of rendering and calculating, it remains responsive to user input.

In the React.js rendering cycle, when a user clicks on an element with an attached click event handler, React.js will respond to that click event. **The click event is captured by the browser and then passed to React.js for handling.**

React.js uses a mechanism called "event delegation" to efficiently manage and handle events. Instead of attaching individual event listeners to each element, React.js captures events at a higher level, typically at the root of the component tree. It then uses a process called "event propagation" or "event bubbling" to determine which specific element triggered the event.

Once React.js receives the click event, it will enqueue the event and process it in the event queue. During the reconciliation phase of the rendering cycle, React.js will check the event queue and execute the corresponding event handler function associated with the clicked element.

The event handler function can contain the desired logic or state updates that should occur in response to the click event. React.js will efficiently handle the event and update the UI as necessary, ensuring a smooth and responsive user experience.

In summary, React.js is designed to handle user interactions, such as click events, even while it's in the process of rendering and calculating. It captures and processes click events using event delegation and event propagation mechanisms, ensuring that the appropriate event handlers are executed in a timely manner.