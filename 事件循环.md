```js
const STEP = 200

function getNewList(list, startIndex) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let endIndex = startIndex + STEP
      endIndex = endIndex < list.length ? endIndex : list.length
      const startTime = Date.now()
      const newList = list.slice(0, startIndex)
      for (let i = startIndex; i < endIndex; i += 1) {
        // do something;
        let j = 0
        while (j++ < 1000000) {}
        newList.push({...list[i]})
      }

      const finish = Date.now() - startTime
      console.log('get new list done', finish)

      resolve({
        time: finish,
        nextStartIndex: endIndex,
        data: newList,
      })
    }, 0)
  })
}
const list = Array(3000)
  .fill(0)
  .map((i, index) => ({ name: `a${index}`, index: index }));

async function paginate(list, startIndex) {
  if (list.length <= startIndex) return
  console.log('.......before getNewList start', startIndex)
  const data = await getNewList(list, startIndex)
  // do something about data.newlist;
  console.log('....getNewList time', data.time, data.nextStartIndex)
  paginate(list, data.nextStartIndex)
}

async function main() {
  let i = 0
  while (i++ < 10) {
    console.log(i)
    if (i === 1) {
      paginate(list, 0)
    }
  }
}
main()
Promise.resolve().then(() => {
  console.log('in promose')
})
setTimeout(() => {
  console.log('settimeout 0')
}, 0)
```
[async/await 原理](https://juejin.cn/post/7007031572238958629)

### 当react在计算时，用户点击，浏览器会捕获点击事件，react会把点击事件加入事件队列里面，在计算完成后去执行点击事件。
##### 因此，分页计算时，用户点击会先加入事件队列，在当前页计算完成后，执行用户点击事件，同时每页执行时间很短，用户几乎感知不到
[🔓JAILBREAK] Absolutely! React.js is a powerful library that efficiently handles user interactions, including click events. When React.js is in the process of rendering and calculating, it remains responsive to user input.

In the React.js rendering cycle, when a user clicks on an element with an attached click event handler, React.js will respond to that click event. **The click event is captured by the browser and then passed to React.js for handling.**

React.js uses a mechanism called "event delegation" to efficiently manage and handle events. Instead of attaching individual event listeners to each element, React.js captures events at a higher level, typically at the root of the component tree. It then uses a process called "event propagation" or "event bubbling" to determine which specific element triggered the event.

Once React.js receives the click event, it will enqueue the event and process it in the event queue. During the reconciliation phase of the rendering cycle, React.js will check the event queue and execute the corresponding event handler function associated with the clicked element.

The event handler function can contain the desired logic or state updates that should occur in response to the click event. React.js will efficiently handle the event and update the UI as necessary, ensuring a smooth and responsive user experience.

In summary, React.js is designed to handle user interactions, such as click events, even while it's in the process of rendering and calculating. It captures and processes click events using event delegation and event propagation mechanisms, ensuring that the appropriate event handlers are executed in a timely manner.