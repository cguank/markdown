## 含义
把运算符写在操作数之后，称为逆波兰表达式(Reverse Polish Expression)或后缀表达式(Suffix Expression)，如AB+；
## 算法
将中缀表达式转换成后缀表达式算法：
1. 从左至右扫描一中缀表达式。
2. 若读取的是操作数，则判断该操作数的类型，并将该操作数存入操作数堆栈
3. 若读取的是运算符
  (1) 该运算符为左括号"("，则直接存入运算符堆栈。
  (2) 该运算符为右括号")"，则输出运算符堆栈中的运算符到操作数堆栈，直到遇到左括号为止。
  (3) 该运算符为非括号运算符：
      (a) 若运算符堆栈栈顶的运算符为括号，则直接存入运算符堆栈。
      (b) 若比运算符堆栈栈顶的运算符优先级高，则直接存入运算符堆栈。
      (c) 若比运算符堆栈栈顶的运算符优先级低或相等，则输出栈顶运算符到操作数堆栈，并将当前运算符压入运算符堆栈。
4. 当表达式读取完成后运算符堆栈中尚有运算符时，则依序取出运算符到操作数堆栈，直到运算符堆栈为空。
 ## 实现
 ```js
const str = '2*((5-3)*4)-16/2';

const weight = {
  '+': 2,
  '-': 2,
  '*': 3,
  '/': 3,
  '(': 1,
  '#': 0
};

function getPostExpression (str) {
  const computeArr = strToComputeArray(str);
  console.log(computeArr);
  const result = [];
  const operator = ['#'];
  for (let item of computeArr) {
    if (!isNaN(item)) {
      result.push(item);
      continue;
    }
    if (item === '(') {
      operator.push('(')
    } else if (item === ')') {
      let topOperator = operator.pop();
      while (topOperator !== '(') {
        result.push(topOperator);
        topOperator = operator.pop();
      }
    } else {
      const itemWeight = weight[item];
      const topOperator = operator[operator.length - 1];
      const topOperatorWeight = weight[topOperator];
      if (itemWeight <= topOperatorWeight) {
        operator.pop();
        result.push(topOperator);
      }
      operator.push(item)
    }
  }
  let topOperator = operator.pop();
  while (topOperator!=='#') {
    result.push(topOperator);
    topOperator = operator.pop();
  }
  return result;
}

function strToComputeArray (str) {
  const result = [];
  let num = '';
  for (let item of str) {
    if (isNaN(item)) {
      if (num) result.push(parseInt(num, 10));
      num = '';
      result.push(item);
    } else {
      num += item;
    }
  }
  if (num) result.push(parseInt(num, 10));
  return result
}

console.log(getPostExpression(str));
```
 
 